

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>深入理解java多线程 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Asrieal's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/cover/wallhaven-j5mz95.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="深入理解java多线程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-24 19:13" pubdate>
        2021年5月24日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      193
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">深入理解java多线程</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>写在前面：本文是学习多线程过程中的笔记，部分内容参考网上博客以及《JAVA高并发程序设计》作为补充，如有错误，还请谅解。</p>
</blockquote>
<h2 id="1-多线程概念"><a href="#1-多线程概念" class="headerlink" title="1.多线程概念"></a>1.多线程概念</h2><blockquote>
<p>什么是多线程？为什么要使用多线程？多线程是如何实现的？如何保证线程的运行安全？</p>
</blockquote>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210428104408909.png" srcset="/img/loading.gif" lazyload alt="必知基本概念"></p>
<p>线程（Thread）是一份独立运行的程序，有自己专用的运行栈。</p>
<ul>
<li><p>耗时的操作使用线程，提高应用程序响应。</p>
</li>
<li><p>多CPU系统中，使用线程提高CPU利用率。</p>
</li>
<li><p>并行操作时使用线程，并发线程响应用户的请求。</p>
</li>
<li><p>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独<br>立的运行部分，这样的程序会利于理解和修改。</p>
</li>
</ul>
<h3 id="1-查看进程和线程的方法"><a href="#1-查看进程和线程的方法" class="headerlink" title="1.查看进程和线程的方法"></a>1.查看进程和线程的方法</h3><p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20201218110254483.png" srcset="/img/loading.gif" lazyload alt="查看进程和线程的方法"></p>
<h3 id="2-java如何保证线程安全"><a href="#2-java如何保证线程安全" class="headerlink" title="2.java如何保证线程安全"></a>2.java如何保证线程安全</h3><p>线程安全体现在三个方面：</p>
<p><strong>原子性</strong></p>
<p>提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）</p>
<p><strong>可见性</strong></p>
<p>一个线程对主内存的修改可以及时地被其他线程看到（synchronized,volatile）</p>
<p><strong>有序性</strong></p>
<p>一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</p>
<p>可以使用volatile、synchronized、lock防止指令重排对线程安全的影响。</p>
<hr>
<h4 id="什么是可见性"><a href="#什么是可见性" class="headerlink" title="什么是可见性"></a>什么是可见性</h4><blockquote>
<p>为什么会存在可见性的问题？如何解决？</p>
</blockquote>
<p>假设频繁的从内存中读取一个变量run，用于判断线程是否继续运行。</p>
<p>1.初始获取变量</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501164524529.png" srcset="/img/loading.gif" lazyload alt="image-20210501164524529"></p>
<p>2.JIT即时编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问以提高效率</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501164613371.png" srcset="/img/loading.gif" lazyload alt="image-20210501164613371"></p>
<p>3.无法知道主内存的值是否有改动</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501164711229.png" srcset="/img/loading.gif" lazyload alt="image-20210501164711229"></p>
<p><strong>解决方法：</strong>使用<code>volatile</code>（表示易变关键字的意思），它可以用来修饰<code>成员变量</code>和<code>静态成员变量</code>，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p>
<p><strong>实现原理：</strong></p>
<ul>
<li>对 volatile 变量的<code>写指令后</code>会加入<code>写屏障</code>。(<strong>保证写屏障之前的写操作, 都能同步到主存中</strong>)</li>
</ul>
<p>写屏障之前的所有改动都能同步到内存中去。</p>
<p>写屏障会确保<strong>指令重排序</strong>时，<strong>不会将写屏障之前的代码排在写屏障之后</strong></p>
<ul>
<li>对 volatile 变量的<code>读指令前</code>会加入<code>读屏障</code>。(保证读屏障之后的读操作, 都能读到主存的数据)</li>
</ul>
<p>读屏障保证在这之后，加载的是最新的数据。</p>
<p>读屏障会确保指令重排序时，<strong>不会将读屏障之后的代码排在读屏障之前</strong></p>
<h4 id="什么是happens-before规则"><a href="#什么是happens-before规则" class="headerlink" title="什么是happens-before规则"></a>什么是happens-before规则</h4><p>规定了对共享变量的写操作,对其它线程的读操作可见的规则。<strong>如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见</strong></p>
<ul>
<li><p>volatile规则：<strong>volatile 变量的写，对接下来其它线程对该变量的读可见</strong></p>
</li>
<li><p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p>
</li>
<li><p>监视器锁规则：解锁后的一个变量，对随后对这个锁的加锁变量是读可见的</p>
</li>
<li><p><strong>start()规则：线程 start() 前对变量的写，对该线程开始后对该变量的读可见</strong></p>
</li>
<li><p>Join()规则：线程结束前中对变量的写，结束以后其他线程再去读是读可见的</p>
</li>
<li><p>程序中断规则：线程中断之前的写，在中断之后其他线程是读可见的</p>
</li>
<li><p>对象finalize规则：对默认值的写</p>
</li>
<li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C</p>
</li>
</ul>
<h2 id="2-线程创建以及命令"><a href="#2-线程创建以及命令" class="headerlink" title="2.线程创建以及命令"></a>2.线程创建以及命令</h2><p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210428191812885.png" srcset="/img/loading.gif" lazyload alt="image-20210428191812885"></p>
<h3 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1.创建线程"></a>1.创建线程</h3><h4 id="继承thread"><a href="#继承thread" class="headerlink" title="继承thread"></a>继承thread</h4><ol>
<li>类继承thread类</li>
<li>重写run方法</li>
<li>调用start开启线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TestThread1 testThread1 = <span class="hljs-keyword">new</span> TestThread1();<br>        testThread1.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</p>
<p>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出IllegalThreadStateException异常。</p>
</blockquote>
<ul>
<li>使用<code>继承方式</code>的好处是，在<code>run()方法</code>内获取当前线程<code>直接使用this</code>就可以了，无须使用Thread.currentThread()方法。</li>
</ul>
<h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><ol>
<li>实现runnable接口</li>
<li>重写run方法</li>
<li>执行线程需要丢入runnable接口实现类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">runnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        runnable instance = <span class="hljs-keyword">new</span> runnable();<br><span class="hljs-comment">//        Thread thread = new Thread(instance);</span><br><span class="hljs-comment">//        thread.start();</span><br>        <span class="hljs-keyword">new</span> Thread(instance).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不一样的是 需要传入thread对象然后再start</p>
<h4 id="比较Thread类与Runnable接口"><a href="#比较Thread类与Runnable接口" class="headerlink" title="比较Thread类与Runnable接口"></a>比较Thread类与Runnable接口</h4><ul>
<li>由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。</li>
<li>Runnable接口出现更符合面向对象，将线程单独进行对象的封装。</li>
<li>Runnable接口出现，降低了线程对象和线程任务的耦合性。</li>
<li>如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。</li>
</ul>
<h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p>我们使用<code>Runnable</code>和<code>Thread</code>来创建一个新的线程。但是它们有一个弊端，就是<code>run</code>方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p>
<p><code>Callable</code>与<code>Runnable</code>类似，同样是只有一个抽象方法的函数式接口。不同的是，<code>Callable</code>提供的方法是<strong>有返回值</strong>的，而且支持<strong>泛型</strong>。</p>
<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p>返回有返回值的结果</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p><strong>函数式接口</strong>：接口只有一个抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">runnable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建接口对象，省略创建类</span><br>        ILIKE test = ()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;lambda&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;lambda2&quot;</span>);<br>        &#125;;<br>        test.lambda();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILIKE</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lambda</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>究极简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ILIKE test = a-&gt;System.out.println(<span class="hljs-string">&quot;lambda&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>通常的调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">runnable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LIKE like = <span class="hljs-keyword">new</span> LIKE();<br>        like.lambda();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//函数式接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILIKE</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lambda</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LIKE</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ILIKE</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lambda</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I LIKE&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//不写类的名字，直接新建一个接口对象</span><br>    ILIKE like = <span class="hljs-keyword">new</span> ILIKE() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lambda</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;like 4&quot;</span>);<br>        &#125;<br>    &#125;;<br>    like.lambda();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-终止线程"><a href="#2-终止线程" class="headerlink" title="2.终止线程"></a>2.终止线程</h3><p>stop函数会直接终止线程，并且立即释放这个线程所持有的锁。</p>
<p>设置一个stopMe标记，当线程处理完事情后再检查标志位决定是否停止。</p>
<h3 id="3-线程中断"><a href="#3-线程中断" class="headerlink" title="3.线程中断"></a>3.线程中断</h3><p>Thread.interrupt  中断</p>
<p>Thread.isInterrupted  判断是否被中断</p>
<p>Thread.interrupted  判断是否被中断，并且清除中断状态。</p>
<ul>
<li>如果<code>一个线程在在运行中被打断</code>，<strong>打断标记会被置为true</strong></li>
<li>如果是打断<code>因sleep wait join方法而被阻塞的线程</code>，会将<strong>打断标记置为false</strong></li>
</ul>
<h3 id="4-等待和通知（wait，notify）"><a href="#4-等待和通知（wait，notify）" class="headerlink" title="4.等待和通知（wait，notify）"></a>4.等待和通知（wait，notify）</h3><p>wait会让线程进入等待队列，并且释放锁的资源。</p>
<p>notify会唤醒线程，随机在等待队列中唤醒一个线程。</p>
<p>wait使用的时候必须配合synchronzied，因为wait使用的时候必先释放锁，所以在此之前要枷锁。</p>
<p>这里具体，每个obiect对象都有个对象头，对象头可以通过指针连接到一个对象的监视器moniter。moniter包括owner，等待队列wait，入口队列entry，owner代表当前被哪个线程给占用了。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210428110758716.png" srcset="/img/loading.gif" lazyload alt="image-20210428110758716"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501140300045.png" srcset="/img/loading.gif" lazyload alt="image-20210501140300045"></p>
<ul>
<li>处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。但是有所区别：<ul>
<li>BLOCKED状态的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li>
<li>WAITING状态的线程是获得了对象的锁，但是自身的原因无法执行synchroized的临界区资源需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li>
</ul>
</li>
</ul>
<ul>
<li><strong><code>处于BLOCKED状态的线程会在锁被释放的时候被唤醒</code></strong></li>
<li><strong><code>处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。然后它会进入到EntryList, 重新竞争锁</code></strong> (此时就将锁升级为<code>重量级锁</code>)</li>
</ul>
<p><strong>wait和sleep的区别</strong></p>
<ul>
<li>Sleep是<strong>Thread类的静态方法</strong>，Wait是<strong>Object的方法</strong>，Object又是所有类的父类，所以所有类都有Wait方法。</li>
<li>Sleep在阻塞的时候<strong>不</strong>会释放锁，而Wait在阻塞的时候<strong>会</strong>释放锁 (不释放锁的话, 其他线程就无法唤醒该线程了)</li>
<li>Sleep方法不需要与synchronized一起使用，而<strong>Wait方法需要与synchronized一起使用</strong>（wait/notify等方法, 必须要使用对象锁来调用）</li>
</ul>
<h3 id="5-挂起和继续执行"><a href="#5-挂起和继续执行" class="headerlink" title="5.挂起和继续执行"></a>5.挂起和继续执行</h3><p>suspend和resume</p>
<p>线程暂停不会释放任何的资源。</p>
<h3 id="6-join"><a href="#6-join" class="headerlink" title="6.join"></a>6.join</h3><p>等待当前线程执行完毕，join 本质是让调用线程wait方法在房前线程对象实例上。</p>
<p><strong>join的原理</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501142410255.png" srcset="/img/loading.gif" lazyload alt="image-20210501142410255"></p>
<h3 id="7-volatile关键字"><a href="#7-volatile关键字" class="headerlink" title="7.volatile关键字"></a>7.volatile关键字</h3><p>保证变量的可见性和有序性。声明变量是不稳定的，其他线程可以立刻知道该变量的改动。</p>
<p>如果没有volatile这个字段，ReaderThread会无法看到变量的修改</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210428111739774.png" srcset="/img/loading.gif" lazyload alt="image-20210428111739774"></p>
<p>但是volatile不能代替锁，比如volatile int i;  i++;</p>
<p>在字节码中的操作：先把常数拷贝下来，再加，再拷贝过去。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430153855788.png" srcset="/img/loading.gif" lazyload alt="image-20210430153855788"></p>
<p>volatile实现了读屏障和写屏障保证可见性和单线有序性。</p>
<p>举例：</p>
<p><strong>double-checked locking(双重检查锁) 单例模式</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501181209944.png" srcset="/img/loading.gif" lazyload alt="image-20210501181209944"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501181421656.png" srcset="/img/loading.gif" lazyload alt="image-20210501181421656"></p>
<ul>
<li>懒汉式单例</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 (也就是上面的第二个单例)</li>
<li>有隐含的: 但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外, 这样会导致synchronized无法保证指令的有序性, 此时可能会导致指令重排问题</li>
</ul>
<h3 id="8-synchronized关键字"><a href="#8-synchronized关键字" class="headerlink" title="8.synchronized关键字"></a>8.synchronized关键字</h3><p>保证线程完全同步。</p>
<p>synchronized是如何实现？可重入锁？如何给jvm加锁？</p>
<p><strong>三种实现方法：</strong></p>
<ul>
<li>指定加锁对象</li>
<li>直接作用于实例方法</li>
<li>直接作用于静态方法</li>
</ul>
<p>只有在锁住相同的对象，或者锁住相同的类的时候才会互斥，一个对象一个类也不会互斥。（8种锁案例分析）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37989980/article/details/111400237">Java并发编程(二) : 线程安全问题、synchronized保证线程安全、private或final的重要性、线程八锁问题分析、变量的线程安全分析_Guizy-CSDN博客</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(instance)&#123;<br>	i++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;<br>    i++;<br>&#125;<br><span class="hljs-comment">//作用于实例方法，等同于加在this对象中</span><br></code></pre></td></tr></table></figure>

<p>创建多个线程对象时，使用的是不同的锁，把实例变成静态后就只用一把锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;<br>    i++; <br>&#125;<span class="hljs-comment">//等同于锁在类对象</span><br><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            value++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            value--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Room room = <span class="hljs-keyword">new</span> Room();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.increment()<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, room.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>面向对象的加锁。</p>
<h3 id="9线程的运行原理"><a href="#9线程的运行原理" class="headerlink" title="9线程的运行原理"></a>9线程的运行原理</h3><p><strong>1.虚拟机栈和栈帧</strong></p>
<p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。当Java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧(在栈顶)，对应着当前正在执行的那个方法</p>
<p><strong>2.线程上下文切换（Thread Context Switch)</strong></p>
<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程</p>
<ul>
<li><strong>线程的 cpu 时间片用完</strong>(每个线程轮流执行，看前面并行的概念)</li>
<li><strong>垃圾回收</strong></li>
<li><strong>有更高优先级的线程需要运行</strong></li>
<li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li>
</ul>
<p>当Thread Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。</p>
<ul>
<li><code>线程的状态</code>包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会<code>影响性能</code></li>
</ul>
<h3 id="10两阶段终止模式"><a href="#10两阶段终止模式" class="headerlink" title="10两阶段终止模式"></a>10两阶段终止模式</h3><p>应用场景，监控机制。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430100800925.png" srcset="/img/loading.gif" lazyload alt="image-20210430100800925"></p>
<h3 id="11-线程安全分析"><a href="#11-线程安全分析" class="headerlink" title="11.线程安全分析"></a>11.线程安全分析</h3><p><strong>成员变量和静态变量的线程安全</strong></p>
<ul>
<li><code>如果变量没有在线程间共享，那么变量是安全的</code></li>
<li>如果变量在线程间共享<ul>
<li>如果只有<code>读操作</code>，则<code>线程安全</code></li>
<li>如果有<code>读写操作</code>，则这段代码是<code>临界区</code>，<code>需要考虑线程安全</code></li>
</ul>
</li>
</ul>
<p><strong>局部变量线程安全分析</strong></p>
<ul>
<li><p>局部变量<code>【局部变量被初始化为基本数据类型】是安全的</code></p>
</li>
<li><p>但局部变量引用的对象则未必 （要看该对象是否被共享且被执行了读写操作）</p>
<ul>
<li>如果<code>该对象没有逃离方法的作用范围</code>，它是<code>线程安全的</code></li>
<li>如果<code>该对象逃离方法的作用范围</code>，需要<code>考虑线程安全</code></li>
</ul>
</li>
<li><p>局部变量表是存在于栈帧中, 而虚拟机栈中又包括很多栈帧, 虚拟机栈是线程私有的;</p>
</li>
</ul>
<p>一个逃离方法作用范围的例子：引用的都是同一个对象中的 list 成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        UnsafeTest unsafeTest = <span class="hljs-keyword">new</span> UnsafeTest();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                unsafeTest.method1();<br>            &#125;,<span class="hljs-string">&quot;线程&quot;</span>+i).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeTest</span></span>&#123;<br>    ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            method2();<br>            method3();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        arrayList.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>        arrayList.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>此时list是一个局部的变量，局部变量放在栈帧中，是虚拟机私有的。</p>
<ul>
<li>因为method1方法, 将<code>arrayList</code>传给method2,method3方法, 此时他们三个方法<code>共享这同一个arrayList</code>, 此时<strong>不会被其他线程访问到</strong>, 所以不会出现<code>线程安全问题</code>, 因为<code>这三个方法使用的同一个线程</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            method2(arrayList);<br>            method3(arrayList);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(List&lt;String&gt; arrayList)</span> </span>&#123;<br>        arrayList.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(List&lt;String&gt; arrayList)</span> </span>&#123;<br>        arrayList.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37989980/article/details/111400237">Java并发编程(二) : 线程安全问题、synchronized保证线程安全、private或final的重要性、线程八锁问题分析、变量的线程安全分析_Guizy-CSDN博客</a></p>
<p>线程安全实例分析。</p>
<h3 id="12-线程状态转换"><a href="#12-线程状态转换" class="headerlink" title="12.线程状态转换"></a>12.线程状态转换</h3><p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501152913941.png" srcset="/img/loading.gif" lazyload alt="image-20210501152913941"></p>
<p><strong>1、NEW &lt;–&gt; RUNNABLE</strong><br>t.start()方法时, NEW –&gt; RUNNABLE<br><strong>2、RUNNABLE &lt;–&gt; WAITING</strong><br>线程用synchronized(obj)获取了对象锁后<br>调用 obj.wait()方法时，t 线程进入waitSet中, 从RUNNABLE –&gt; WAITING<br>调用 obj.notify()，obj.notifyAll()，t.interrupt() 时, 唤醒的线程都到entrySet阻塞队列成为BLOCKED状态, 在阻塞队列,和其他线程再进行 竞争锁<br>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE<br>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED<br><strong>3、RUNNABLE &lt;–&gt; WAITING</strong><br>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING ,注意是当前线程在t线程对象在waitSet上等待<br>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE<br><strong>4、RUNNABLE &lt;–&gt; WAITING</strong><br>当前线程调用 LockSupport.park() 方法会让当前线程从RUNNABLE –&gt; WAITING<br>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE<br>Runnable 和 Timed-Waiting的相互转换</p>
<p><strong>5、RUNNABLE &lt;–&gt; TIMED_WAITING (带超时时间的wait)</strong><br>t 线程用synchronized(obj) 获取了对象锁后<br>调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING<br>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时; 唤醒的线程都到entrySet阻塞队列成为BLOCKED状态, 在阻塞队列,和其他线程再进行 竞争锁<br>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE<br>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED<br><strong>6、RUNNABLE &lt;–&gt; TIMED_WAITING</strong><br>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING 注意是当前线程在t 线程对象的waitSet等待<br>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE<br><strong>7、RUNNABLE &lt;–&gt; TIMED_WAITING</strong><br>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING<br>当前线程等待时间超过了 n 毫秒或调用了线程的 interrupt() ，当前线程从 TIMED_WAITING –&gt; RUNNABLE<br><strong>8、RUNNABLE &lt;–&gt; TIMED_WAITING</strong><br>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE –&gt; TIMED_WAITING<br>调用LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE<br><strong>9、RUNNABLE &lt;–&gt; BLOCKED</strong><br>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED, 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED<br><strong>10、 RUNNABLE &lt;–&gt; TERMINATED</strong><br>当前线程所有代码运行完毕，进入 TERMINATED</p>
<h2 id="3-JDK并发包"><a href="#3-JDK并发包" class="headerlink" title="3.JDK并发包"></a>3.JDK并发包</h2><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
</ul>
<p>常见线程安全的类。</p>
<h3 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1.ReentrantLock"></a>1.ReentrantLock</h3><p>方法：lock,unlock,trylock,lockInterruptibly</p>
<p>必须要手动加锁和释放锁，能够多次加锁。</p>
<p>特点是：</p>
<ul>
<li>可重入</li>
</ul>
<p>可重入锁是指<code>同一个线程如果首次获得了这把锁</code>，那么因为它是这把<code>锁的拥有者</code>，因此 <strong>有权利再次获取这把锁</strong></p>
<ul>
<li>中断响应</li>
</ul>
<p>可以中途直接放弃任务，直接释放资源。</p>
<p><strong><code>synchronized</code></strong> 和 <strong><code>reentrantlock.lock()</code></strong> 的锁, 是不可被打断的。</p>
<p>通过<code>lock.lockInterruptibly()</code>获取的锁对象, 可以通过调用<strong>阻塞线程的interrupt()方法</strong>来打断，直接释放资源。</p>
<ul>
<li>锁申请等待</li>
</ul>
<p>lock.tryLock()限时等待，如果超时则返回false，并从阻塞队列中移除。</p>
<ul>
<li>公平锁</li>
</ul>
<p>在创建的时候ReentrantLock（boolean fair）;如果开启公平锁了，需要请求一个队列来维护，公平锁成本高，性能低下。进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。</p>
<p>可以建立多个条件变量，建立不同的condition,对应不同的锁机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentranLock lock = <span class="hljs-keyword">new</span> ReentranLock();  <span class="hljs-comment">//创建可重入锁</span><br><br>lock.lock();  <span class="hljs-comment">//锁住</span><br><br>Condition c1 = lock.<span class="hljs-function">new <span class="hljs-title">Condition</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//创建新的条件</span><br><br>Condition c2 = lock.<span class="hljs-function">new <span class="hljs-title">Condition</span><span class="hljs-params">()</span></span>;<br><br>c1.await()<br>c2.await()<br>c1.signal();<br>c2.signal();<br></code></pre></td></tr></table></figure>



<ul>
<li>await 前需要 获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject (条件变量)中等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
<li>signal 方法用来唤醒条件变量(等待室)汇总的某一个等待的线程</li>
<li>signalAll方法, 唤醒条件变量(休息室)中的所有线程</li>
</ul>
<h3 id="2-ReentrantLock和synchronized的区别"><a href="#2-ReentrantLock和synchronized的区别" class="headerlink" title="2.ReentrantLock和synchronized的区别"></a>2.ReentrantLock和synchronized的区别</h3><p>p81</p>
<h3 id="3-ReentrantLock实现原理"><a href="#3-ReentrantLock实现原理" class="headerlink" title="3.ReentrantLock实现原理"></a>3.ReentrantLock实现原理</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508213426067.png" srcset="/img/loading.gif" lazyload alt="image-20210508213426067"></p>
<h4 id="非公平锁加锁的原理"><a href="#非公平锁加锁的原理" class="headerlink" title="非公平锁加锁的原理"></a>非公平锁加锁的原理</h4><p>构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync = <span class="hljs-keyword">new</span> NonfairSync();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>lock方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 没有竞争时, 直接加锁</span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-comment">// 设置持有锁的线程</span><br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 有竞争, 会调用这个方法</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>acquire方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>		<span class="hljs-comment">// 再次尝试加锁, 然后为 true 就不走下面逻辑，为 false，则创建一个 Node 节点对象加入到等待队列中去</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508214343811.png" srcset="/img/loading.gif" lazyload alt="image-20210508214343811"></p>
<p>调用acquire后再次使用tryAcquire判断把state从0改1，如果失败了就进入addWaiter，构造队列。</p>
<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li>
<li>Node 的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508214641480.png" srcset="/img/loading.gif" lazyload alt="image-20210508214641480"></p>
<p>之后进入acquireQueued逻辑。</p>
<p>首先尝试获取锁，失败后进入park阻塞</p>
<p>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false，-1代表有责任唤醒上一个节点。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508231709352.png" srcset="/img/loading.gif" lazyload alt="image-20210508231709352"></p>
<p>最后节点进入阻塞状态。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508232002604.png" srcset="/img/loading.gif" lazyload alt="image-20210508232002604"></p>
<p>经过多次的竞争后，锁的形态变成这样：</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508232323347.png" srcset="/img/loading.gif" lazyload alt="image-20210508232323347"></p>
<p>此时我们的Thread0线程结束了。<strong>情况一：无其他锁竞争</strong></p>
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p>
<ul>
<li>设置 exclusiveOwnerThread 为 null，把锁释放。</li>
<li>state = 0</li>
</ul>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508233056121.png" srcset="/img/loading.gif" lazyload alt="image-20210508233056121"></p>
<p>如果当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程：</p>
<p>unparkSuccessor 中会找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p>
<p>回到 Thread-1 的 acquireQueued 流程</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508233336573.png" srcset="/img/loading.gif" lazyload alt="image-20210508233336573"></p>
<p>原本的节点断开，当前这个节点就变成了头节点。</p>
<p>exclusiveOwnerThread 为 Thread-1，state = 1<br>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread<br>原本的 head 因为从链表断开，而可被垃圾回收</p>
<p><strong>如果有其他线程竞争</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509103116242.png" srcset="/img/loading.gif" lazyload alt="image-20210509103116242"></p>
<p>如果不巧又被 Thread-4 占了先</p>
<ol>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ol>
<h4 id="锁重入原理"><a href="#锁重入原理" class="headerlink" title="锁重入原理"></a>锁重入原理</h4><p>会把状态+1</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509104545454.png" srcset="/img/loading.gif" lazyload alt="image-20210509104545454"></p>
<p>释放的话：</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509104731410.png" srcset="/img/loading.gif" lazyload alt="image-20210509104731410"></p>
<p>解锁让状态自减。</p>
<h4 id="可打断的原理"><a href="#可打断的原理" class="headerlink" title="可打断的原理"></a>可打断的原理</h4><p>不可打断模式</p>
<p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了。在代码中把打断标记设为true，运行时检查。</p>
<p>可打断模式</p>
<p>被打断的时候会抛出异常，从而不再进入for循环。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509111307501.png" srcset="/img/loading.gif" lazyload alt="image-20210509111307501"></p>
<h4 id="公平锁的实现"><a href="#公平锁的实现" class="headerlink" title="公平锁的实现"></a>公平锁的实现</h4><p>非公平锁在竞争锁的时候，如果看到状态是0，就直接抢占获取锁，不会去检查AQS队列。</p>
<p>公平锁会检查队列。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509111838142.png" srcset="/img/loading.gif" lazyload alt="image-20210509111838142"></p>
<p>判断队列中是否有线程，有线程的话是不是本线程。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509112005030.png" srcset="/img/loading.gif" lazyload alt="image-20210509112005030"></p>
<h4 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h4><p><strong>await</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509124530345.png" srcset="/img/loading.gif" lazyload alt="image-20210509124530345"></p>
<p>创建一个条件变量对象，并且调用。</p>
<p>进入addConditionWaiter流程，创建Node状态为-2的节点，关联线程，加入等待队列的尾部。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509123929211.png" srcset="/img/loading.gif" lazyload alt="image-20210509123929211"></p>
<p>进入fullyRelease清除所有锁，重入锁全部清楚，并且唤醒下一个节点，让他去竞争锁。</p>
<p><strong>signal流程</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509125731195.png" srcset="/img/loading.gif" lazyload alt="image-20210509125731195"></p>
<p>把等待的节点加入到队列中，其中thread状态改为-1，他的状态从-2改成0.</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509125849464.png" srcset="/img/loading.gif" lazyload alt="image-20210509125849464"></p>
<h3 id="4-信号量semaphore"><a href="#4-信号量semaphore" class="headerlink" title="4.信号量semaphore"></a>4.信号量semaphore</h3><p>可以指定多个线程同时访问某个资源，主要是用来限流，在高峰期的时候让线程阻塞。</p>
<p>假设信号量的线程定义为3，现在有5个节点来竞争，三个线程进行运行，两个进行阻塞。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210510145002323.png" srcset="/img/loading.gif" lazyload alt="image-20210510145002323"></p>
<p>当有一个线程运行结束的时候，state变成1，</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210510145149179.png" srcset="/img/loading.gif" lazyload alt="image-20210510145149179"></p>
<h3 id="5-读写锁ReadWriteLock"><a href="#5-读写锁ReadWriteLock" class="headerlink" title="5.读写锁ReadWriteLock"></a>5.读写锁ReadWriteLock</h3><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>是一种锁分离的操作，当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>读锁不支持条件变量。写锁支持。</li>
<li>重入时升级不持支：先有读锁，再去获得写锁不支持。</li>
<li>支持降级：现有写锁，再去获得读锁。</li>
</ul>
<p><strong>读写锁应用在缓存上：</strong></p>
<p>先更新数据库，后清空缓存，虽然有短时间可能会查询错误，但是后续查询都可以的到新的值。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509140603659.png" srcset="/img/loading.gif" lazyload alt="image-20210509140603659"></p>
<p>此时加入读写锁可保证数据一致性。</p>
<h4 id="读写锁的原理"><a href="#读写锁的原理" class="headerlink" title="读写锁的原理"></a>读写锁的原理</h4><p>1.首先执行 t1 w.lock，t2 r.lock </p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509141441100.png" srcset="/img/loading.gif" lazyload alt="image-20210509141441100"></p>
<p>加写锁源码，</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509143256222.png" srcset="/img/loading.gif" lazyload alt="image-20210509143256222"></p>
<p>加完写锁之后如果再去加读锁的话。</p>
<p>加读锁源码，</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509145448005.png" srcset="/img/loading.gif" lazyload alt="image-20210509145448005"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509151617521.png" srcset="/img/loading.gif" lazyload alt="image-20210509151617521"></p>
<p>返回0代表后续节点不会唤醒，正数表示成功，后续还有n个节点需要唤醒。</p>
<p>tryAcquireShared函数源码：</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509151849104.png" srcset="/img/loading.gif" lazyload alt="image-20210509151849104"></p>
<p>进入acquire逻辑，是使用shared参数的。此时线程进入等待队列，同时也会再尝试获得锁3次。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509152637717.png" srcset="/img/loading.gif" lazyload alt="image-20210509152637717"></p>
<p>最后进入阻塞状态。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509152656738.png" srcset="/img/loading.gif" lazyload alt="image-20210509152656738"></p>
<p><strong>再继续执行t3 r.lock，t4 w.lock</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509153003762.png" srcset="/img/loading.gif" lazyload alt="image-20210509153003762"></p>
<p><strong>（解锁流程）执行 t1 w.unlock</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509153518167.png" srcset="/img/loading.gif" lazyload alt="image-20210509153518167"></p>
<p>执行唤醒流程，让t2线程被唤醒。t2线程是加读锁，所以开始进入获得锁的流程。执行 tryAcquireShared 成功则让读锁计数加一</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509165030351.png" srcset="/img/loading.gif" lazyload alt="image-20210509165030351"></p>
<p>由于 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509165819008.png" srcset="/img/loading.gif" lazyload alt="image-20210509165819008"></p>
<p>在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行.</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509165914358.png" srcset="/img/loading.gif" lazyload alt="image-20210509165914358"></p>
<p>这次有共享锁，所以让读锁计数器加一。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509170041166.png" srcset="/img/loading.gif" lazyload alt="image-20210509170041166"></p>
<p>t1和t2在执行中，再继续执行线程。直到unlock解锁。分别让state-1.</p>
<p>此时把头节点改成0，并且尝试唤醒t4线程。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509170325583.png" srcset="/img/loading.gif" lazyload alt="image-20210509170325583"></p>
<p>t4线程是独占的读锁，成功竞争。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210509170501955.png" srcset="/img/loading.gif" lazyload alt="image-20210509170501955"></p>
<h3 id="6-倒计数器CountDownLatch"><a href="#6-倒计数器CountDownLatch" class="headerlink" title="6.倒计数器CountDownLatch"></a>6.倒计数器CountDownLatch</h3><p>其他线程运行计数，当指定数量的其他线程结束运行后，在运行。</p>
<p>等待其他线程运行。await（）等待计数，countDown计数减一。</p>
<p>当state=0的时候获得锁，</p>
<h3 id="7-循环栅栏CyclicBarrier"><a href="#7-循环栅栏CyclicBarrier" class="headerlink" title="7.循环栅栏CyclicBarrier"></a>7.循环栅栏CyclicBarrier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>);  <span class="hljs-comment">//两个计数</span><br>    <br>cyclicBarrier.await(); <span class="hljs-comment">//阻塞，并且计数减一</span><br><br>cyclicBarrier.await();  <span class="hljs-comment">//阻塞，计数减一，到0释放全部</span><br></code></pre></td></tr></table></figure>



<h3 id="8-线程阻塞LockSupport"><a href="#8-线程阻塞LockSupport" class="headerlink" title="8.线程阻塞LockSupport"></a>8.线程阻塞LockSupport</h3><p>用于阻塞线程，不需要预先获得锁，不会抛出异常。</p>
<p>// 暂停当前线程<br>LockSupport.park();<br>// 恢复某个线程的运行<br>LockSupport.unpark(thread);</p>
<p><strong>原理：</strong></p>
<p><code>每个线程</code>都有自己的一个 <code>Parker 对象</code>，由三部分组成 <strong><code>_counter</code>， <code>_cond</code>和 <code>_mutex</code></strong></p>
<ul>
<li>调用park的时候</li>
</ul>
<p>1.首先看看Parker对象中Counter是否为0，如果是0则把线程放入等待队列cond（condition）中，</p>
<p>2.把counter设置为0</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501151544521.png" srcset="/img/loading.gif" lazyload alt="image-20210501151544521"></p>
<ul>
<li>调用unpark的时候</li>
</ul>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501152015830.png" srcset="/img/loading.gif" lazyload alt="image-20210501152015830"></p>
<p>1.unpark首先把许可counter设置为1，然后唤醒等待队列中的线程，线程查询发现counter为1，继续运行线程，并且把counter设置为0；</p>
<p>如果先使用unpark的时候，会把counter设置为1，再使用park的时候，会先检查counter并设置为0，并且继续运行（消耗许可，继续运行）</p>
<h3 id="9-Guava和RateLimiter限流"><a href="#9-Guava和RateLimiter限流" class="headerlink" title="9.Guava和RateLimiter限流"></a>9.Guava和RateLimiter限流</h3><h3 id="10-StampedLock"><a href="#10-StampedLock" class="headerlink" title="10.StampedLock"></a>10.StampedLock</h3><p>使用：配合stamped</p>
<p>加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.readLock();<br>lock.unlockRead(stamp);<br></code></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure>

<p><strong>乐观读</strong>，可以做一次戳校验，如果通过表示没有写操作可以安全使用。如果校验没通过，需要重新获取读锁，保证安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br> <span class="hljs-comment">// 锁升级升级为读锁</span><br>&#125;<br></code></pre></td></tr></table></figure>





<p>注意：<br>StampedLock 不支持条件变量<br>StampedLock 不支持可重入</p>
<h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h2><h3 id="1-线程池的好处"><a href="#1-线程池的好处" class="headerlink" title="1.线程池的好处"></a>1.线程池的好处</h3><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="2-不同的线程池"><a href="#2-不同的线程池" class="headerlink" title="2.不同的线程池"></a>2.不同的线程池</h3><p><code>Executors类</code>提供的工厂方法</p>
<ul>
<li><strong>newFixedThreadPool</strong>（可重用固定线程数的线程池）</li>
</ul>
<p>corePoolSize 和 maximumPoolSize是相同的，FixedThreadPool 使用无界队列 LinkedBlockingQueue。使用无界队列的话maximumPoolSize是一个无效参数，而且该线程池不会拒绝任务，一直到内存溢出。</p>
<ol>
<li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li>
<li>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<ul>
<li><strong>newSingleThreadExecutor</strong>（只有一个线程的线程池）</li>
</ul>
<p>简单的把corePoolSize 设置为1，无救济线程，其他和上边一样，也使用无界队列</p>
<p>和创建一个单线程的<strong>区别</strong>：</p>
<p>1.自己创建单线程，如果任务失败而终止，线程池会创建新的线程。</p>
<p>2.和newFixedThreadPool（1）的区别是，newSingleThreadExecutor使用装饰器模式，不能调用特有方法，不能修改线程数，而newFixedThreadPool还可以修改</p>
<ul>
<li><strong>newCachedThreadPool</strong>（根据需要创建新线程的线程池）</li>
</ul>
<p>corePoolSize为0，maximumPoolSize是无穷大，无空闲线程的话就加入SynchronousQueue队列，而这个队列会直接提交。</p>
<p>适用于任务比较密集，每个任务时间短的情况。</p>
<ul>
<li><strong>ScheduledThreadPoolExecutor</strong>（延迟后运行任务，或者定期执行任务）</li>
</ul>
<p><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p>
<p>主要方法有：</p>
<p>scheduleAtFixedRate()：表示以固定频率执行的任务，如果当前任务耗时较多，超过定时周期period，则当前任务结束后会立即执行。</p>
<p>scheduleWithFixedDelay()：表示以固定延时执行任务，延时是相对当前任务结束为起点计算开始时间。</p>
<h3 id="3-核心线程池的主要参数"><a href="#3-核心线程池的主要参数" class="headerlink" title="3.核心线程池的主要参数"></a>3.核心线程池的主要参数</h3><p>ThreadPoolExecutor类</p>
<p><strong>1、corePoolSize（线程池基本大小）：指定线程数量。</strong>当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</p>
<p><strong>2、maximumPoolSize（线程池最大大小）</strong>：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。（救急线程）</p>
<p><strong>3、keepAliveTime（线程存活保持时间）</strong>当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p>
<p>4、unit： keepAliveTime的单位</p>
<p><strong>5、workQueue（任务队列）</strong>：被提交，但是还未被执行的任务。用于传输和保存等待执行任务的阻塞队列。</p>
<p><strong>6、threadFactory（线程工厂）</strong>：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</p>
<p><strong>7、handler（线程饱和策略</strong>）：拒绝策略。当线程池和队列都满了，再加入线程会执行此策略。</p>
<p><strong>workQueue参数</strong>，用于存放Runnable对象，提供了几种BlockingQueue的接口</p>
<ul>
<li>直接提交的队列：SynchronousQueue对象提供。每一个删除操作都会等待对应的插入操作，每一个插入操作都会等待删除操作。</li>
<li>有界的任务队列：ArrayBlockingQueue，需要带一个参数表示最大容量，线程数小于corePoolSize直接新建，小于maximumPoolSize则加入等待队列，大于maximumPoolSize直接拒绝。</li>
<li>无界的任务队列：等待队列会不断的增加一直到内存耗尽。</li>
<li>优先任务队列：PriorityBlockingQueue </li>
</ul>
<p><strong>线程池的核心逻辑：</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="图解线程池实现原理"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210429150241911.png" srcset="/img/loading.gif" lazyload alt="image-20210429150241911"></p>
<p><strong>拒绝策略</strong></p>
<ul>
<li><strong>AbortPolicy</strong></li>
</ul>
<p>丢弃任务并抛出RejectedExecutionException异常，默认</p>
<ul>
<li><strong>CallerRunsPolicy</strong></li>
</ul>
<p>由调用线程处理该任务</p>
<ul>
<li><strong>DiscardOldestPolicy</strong></li>
</ul>
<p>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</p>
<ul>
<li><strong>DiscardPolicy</strong></li>
</ul>
<p>丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃</p>
<h3 id="4-线程池状态"><a href="#4-线程池状态" class="headerlink" title="4.线程池状态"></a>4.线程池状态</h3><ul>
<li><strong>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</strong></li>
</ul>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508163824408.png" srcset="/img/loading.gif" lazyload alt="image-20210508163824408"></p>
<p>用一个整数保存，可以减少cas的操作。</p>
<h3 id="5-线程池方法"><a href="#5-线程池方法" class="headerlink" title="5.线程池方法"></a>5.线程池方法</h3><p><strong>1.提交任务submit</strong></p>
<p> 提交任务 task，用返回值 Future 获得任务执行结果。</p>
<p>Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，Callable是一个有返回值的，可以同于submit方法。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508193151954.png" srcset="/img/loading.gif" lazyload alt="image-20210508193151954"></p>
<p><strong>invokeAll：提交 tasks 中所有任务</strong>，返回一个队列，队列包括所有结果。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508194901942.png" srcset="/img/loading.gif" lazyload alt="image-20210508194901942"></p>
<p><strong>shutdown</strong></p>
<ul>
<li><strong>将线程池的状态改为 SHUTDOWN</strong></li>
<li><strong>不再接受新任务，但是会将阻塞队列中的任务执行完</strong></li>
</ul>
<p><strong>shutdownNow</strong></p>
<ul>
<li><strong>将线程池的状态改为 STOP</strong></li>
<li><strong>不再接受新任务，也不会在执行阻塞队列中的任务</strong></li>
<li>会将阻塞队列中未执行的任务返回给调用者</li>
<li>并用 interrupt 的方式中断正在执行的任务</li>
</ul>
<p>多线程池，防止线程饥饿状态</p>
<p>线程池线程设置：</p>
<p><strong>CPU 密集型运算</strong>通常采用 <strong><code>cpu 核数 + 1</code></strong></p>
<p><strong>I/O 密集型运算</strong></p>
<h3 id="6-线程异常"><a href="#6-线程异常" class="headerlink" title="6.线程异常"></a>6.线程异常</h3><p>主动捕捉异常</p>
<p>使用 Future，错误信息都被封装进submit方法的返回方法中</p>
<h2 id="5-并发的集合"><a href="#5-并发的集合" class="headerlink" title="5.并发的集合"></a>5.并发的集合</h2><h3 id="1-BlockingQueue（重要）"><a href="#1-BlockingQueue（重要）" class="headerlink" title="1.BlockingQueue（重要）"></a>1.BlockingQueue（重要）</h3><p>BlockingQueue即阻塞队列，它是基于ReentrantLock。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/4180398-89f0d2693361656e.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>在Java中，BlockingQueue是一个接口，它的实现类有ArrayBlockingQueue、DelayQueue、 LinkedBlockingDeque、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。</p>
</blockquote>
<p>ArrayBlockingQueue 更适合做有界队列。LinkedBlockingQueue适合做无界队列。</p>
<p><strong>ArrayBlockingQueue</strong></p>
<p>内部元素放在一个object的数组中。</p>
<p>take方法会从队列中读取元素，如果为空则等待。put方法向队列中压入，如果满了则等待。</p>
<p>当有新元素出队或者入队时，会获得一个通知唤醒，继续执行。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210429130004026.png" srcset="/img/loading.gif" lazyload alt="image-20210429130004026"></p>
<p>notFull是一个condition类，take方法同理。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210429130946397.png" srcset="/img/loading.gif" lazyload alt="image-20210429130946397"></p>
<p>在物理上是数组，在逻辑上是环形的结构，会用takeIndex和putIndex分别标识使队列头部和尾部在数组中的位置。循环调整：</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210429132416245.png" srcset="/img/loading.gif" lazyload alt="image-20210429132416245"></p>
<p>ArrayBlockingQueue的并发阻塞是通过ReentrantLock和Condition来实现的，ArrayBlockingQueue内部只有一把锁，意味着同一时刻只有一个线程能进行入队或者出队的操作。</p>
<p><strong>LinkedBlockingQueue</strong>（锁分离的典型实现）</p>
<p>使用putlock和takelock两把锁实现锁分离。</p>
<p>入队会有一个初始化的Dummy节点占位，</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210510152555346.png" srcset="/img/loading.gif" lazyload alt="image-20210510152555346"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210510152713315.png" srcset="/img/loading.gif" lazyload alt="image-20210510152713315"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506090312161.png" srcset="/img/loading.gif" lazyload alt="image-20210506090312161"></p>
<p>把头节点后一个节点出队，并且初始化为Dummy节点，原来的Dummy节点自己指向自己等待被回收。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210510153118782.png" srcset="/img/loading.gif" lazyload alt="image-20210510153118782"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506090040092.png" srcset="/img/loading.gif" lazyload alt="image-20210506090040092"></p>
<p>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</p>
<p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p>
<p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞<br><strong>性能分析</strong></p>
<p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p>
<p>Linked 支持有界，Array 强制有界<br>Linked 实现是链表，Array 实现是数组<br>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组<br>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的<br>Linked 两把锁，Array 一把锁</p>
<p> LinkedBlockingQueue性能更好，用于大部分场景。主要消费者的消费速度不能太低，以防内存溢出，虽然可以设置边界。</p>
<p>业务场景，订单完成自动发送发票邮件。</p>
<h3 id="2-SynchronousQueue"><a href="#2-SynchronousQueue" class="headerlink" title="2.SynchronousQueue"></a>2.SynchronousQueue</h3><p>SynchronousQueue直接使用CAS实现线程的安全访问。没有任何存放元素的能力。</p>
<p>1.公平模式下，底层实现使用的是<strong>TransferQueue</strong>这个内部队列，它有一个head和tail指针，用于指向当前正在等待匹配的线程节点。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20160917104622034" srcset="/img/loading.gif" lazyload alt="这里写图片描述"></p>
<p>2.线程put1执行 put(1)操作，由于当前没有配对的消费线程，所以put1线程入队列，自旋一小会后睡眠等待，这时队列状态如下：</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20160917104908799" srcset="/img/loading.gif" lazyload alt="这里写图片描述"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20160917104923268" srcset="/img/loading.gif" lazyload alt="这里写图片描述"></p>
<p>3.这时候，来了一个线程take1，执行了 take操作，由于tail指向put2线程，put2线程跟take1线程配对了(一put一take)，这时take1线程不需要入队，但是请注意了，这时候，要唤醒的线程并不是put2，而是put1。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20160917104934690" srcset="/img/loading.gif" lazyload alt="这里写图片描述"></p>
<p>队尾匹配队头出队，先进先出，体现公平原则。</p>
<p><strong>非公平模式</strong>底层的实现使用的是TransferStack，一个栈，实现中用head指针指向栈顶，接着我们看看它的实现模型:</p>
<p>1.线程put1执行 put(1)操作，由于当前没有配对的消费线程，所以put1线程入栈</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20160917104959489" srcset="/img/loading.gif" lazyload alt="这里写图片描述"></p>
<p>2.线程put2再次执行了put(2)操作，跟前面一样，put2线程入栈，自旋一小会后睡眠等待，这时栈状态如下</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20170114114102087" srcset="/img/loading.gif" lazyload alt="这里写图片描述"></p>
<p>3.这时候，来了一个线程take1，执行了take操作，这时候发现栈顶为put2线程，匹配成功，但是实现会先把take1线程入栈，然后take1线程循环执行匹配put2线程逻辑，一旦发现没有并发冲突，就会把栈顶指针直接指向 put1线程</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20160917105037114" srcset="/img/loading.gif" lazyload alt="这里写图片描述"></p>
<p>先入后出，所以非公平。</p>
<h3 id="3-synchronizedMap"><a href="#3-synchronizedMap" class="headerlink" title="3.synchronizedMap()"></a>3.synchronizedMap()</h3><p>给hashmap加了一个锁，效率比较低。一般使用concurrentHashMAP</p>
<p>类似的还有synchronizedList</p>
<h3 id="4-ConcurrentLinkedQueue高效读写队列"><a href="#4-ConcurrentLinkedQueue高效读写队列" class="headerlink" title="4.ConcurrentLinkedQueue高效读写队列"></a>4.ConcurrentLinkedQueue高效读写队列</h3><p>全程使用CAS进行，非常困难。</p>
<h3 id="5-CopyOnWriteArrayList"><a href="#5-CopyOnWriteArrayList" class="headerlink" title="5.CopyOnWriteArrayList"></a>5.CopyOnWriteArrayList</h3><p>读操作是不用加锁的。CopyOnWrite的意思就是，在写入操作的时候同时做一次自我复制。</p>
<p>不修改原有的内容，对原有数据进行一次复制，在副本中修改，写完以后再用副本修改原来的数据。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430000411889.png" srcset="/img/loading.gif" lazyload alt="image-20210430000411889"></p>
<p>写操作，首先使用lock锁住，完全复制数组再更改，最后复制回去。</p>
<h3 id="6-SkipList跳表"><a href="#6-SkipList跳表" class="headerlink" title="6.SkipList跳表"></a>6.SkipList跳表</h3><p>时间复杂度是logn的。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20181029211746472.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>关键的数据节点：</p>
<p><strong>与红黑树的区别：</strong></p>
<p>红黑树的插入和删除需要进行一次全局的调整，跳表的话，只要对局部结构进行调整就够了。在高并发的情况下，需要使用全局锁锁住红黑树。跳表的话只要锁局部就可以了。</p>
<p><strong>与哈希表的区别：</strong>跳表的输出是有序的。</p>
<h3 id="7-AQS"><a href="#7-AQS" class="headerlink" title="7.AQS"></a>7.AQS</h3><p>AbstractQueuedSynchronizer是阻塞式锁和相关的同步器工具的框架。</p>
<ul>
<li><strong>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</strong><ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
</ul>
<ul>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p>使用AQS来自定义一个锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">//CAS加锁，设置owner为当前线程</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-comment">//owner设为空，状态设为0就解锁了</span><br>                setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>                setState(<span class="hljs-number">0</span>);<span class="hljs-comment">//state是volatile的，会有一个写屏障保证写屏障之前都写入内存。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><span class="hljs-comment">//是否持有独占锁</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> MySync mySync = <span class="hljs-keyword">new</span> MySync();<br><br>    <span class="hljs-comment">// 加锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        mySync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 可中断的锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        mySync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 只会尝试一次加锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mySync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 带超时时间的</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> mySync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        mySync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建条件变量</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mySync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>面试：</p>
<p>同步器工具的框架，内部的数据结构有个state这个状态表示锁的状态，用node队列的形式，node里存的是线程。</p>
<h3 id="8-concurrenthashmap（1-8）"><a href="#8-concurrenthashmap（1-8）" class="headerlink" title="8.concurrenthashmap（1.8）"></a>8.concurrenthashmap（1.8）</h3><p><strong>1.8版本</strong></p>
<p>扩容的时候，已近移动的节点会有一个fnode填充，表示已经移动到扩容后的区域。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512142632409.png" srcset="/img/loading.gif" lazyload alt="image-20210512142632409"></p>
<h4 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h4><p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512140214907.png" srcset="/img/loading.gif" lazyload alt="image-20210512140214907"></p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512141310152.png" srcset="/img/loading.gif" lazyload alt="image-20210512141310152"></p>
<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512142526405.png" srcset="/img/loading.gif" lazyload alt="image-20210512142526405"></p>
<p>如果节点是被fnode占据，证明已经移动过了，正在扩容，要帮助进行扩容。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512142834975.png" srcset="/img/loading.gif" lazyload alt="image-20210512142834975"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512144914738.png" srcset="/img/loading.gif" lazyload alt="image-20210512144914738"></p>
<h4 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h4><p>创建桶</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512150216510.png" srcset="/img/loading.gif" lazyload alt="image-20210512150216510"></p>
<h4 id="addCount元素个数计数"><a href="#addCount元素个数计数" class="headerlink" title="addCount元素个数计数"></a>addCount元素个数计数</h4><p>增加了多个累加单元，在多线程的情况下同时增加，</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512154036338.png" srcset="/img/loading.gif" lazyload alt="image-20210512154036338"></p>
<p>还没有累加单元，则创建累加单元通过fullAddCount方法。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512162806880.png" srcset="/img/loading.gif" lazyload alt="image-20210512162806880"></p>
<h4 id="size计算流程"><a href="#size计算流程" class="headerlink" title="size计算流程"></a>size计算流程</h4><p>size计算实际发生在put,remove改变集合元素的操作之中</p>
<ul>
<li>没有竞争发生，向baseCount累加计数</li>
<li>有竞争发生就新建counterCells，向其中一个cell累加计数<ul>
<li>初始有两个cell</li>
<li>竞争激烈会创建新的cell来累加计数</li>
</ul>
</li>
</ul>
<p>首先获得baseCount，然后遍历cell中的数字，相加。</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>创建新的table，然后进行链表移动，如果链表头为null，就替换成fwd（forwardingNode）。锁住，普通节点进行搬迁，树节点进行搬迁。</p>
<h3 id="9-concurrenthashmap（1-7）"><a href="#9-concurrenthashmap（1-7）" class="headerlink" title="9.concurrenthashmap（1.7）"></a>9.concurrenthashmap（1.7）</h3><p>维护了一个segment数组，每个segment数组对应一把锁。而1.7中把锁加在了链表头。</p>
<p>是分段加锁的，不同的segments不冲突，每个HashEntry是数组加链表的结构。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512174335595.png" srcset="/img/loading.gif" lazyload alt="image-20210512174335595"></p>
<p>通过移位属性和掩码属性来计算。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512175127035.png" srcset="/img/loading.gif" lazyload alt="image-20210512175127035"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512175216243.png" srcset="/img/loading.gif" lazyload alt="image-20210512175216243"></p>
<h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><p>可以使用可重入锁。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512181551547.png" srcset="/img/loading.gif" lazyload alt="image-20210512181551547"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512182043571.png" srcset="/img/loading.gif" lazyload alt="image-20210512182043571"></p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>扩容：</p>
<ol>
<li>创建一个新的桶，容量是之前的两倍。</li>
<li>进行一次rehash，把rehash后idx不变的节点重新使用，移动到新的桶中去</li>
<li>如果idx改变了，就创建一个新的节点复制过去，源节点还在</li>
<li>最后把新桶覆盖到原来的老桶</li>
</ol>
<h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><p>用了UNSAFE方法保证了可见性，扩容过程中，get先发生就从旧表取内容，get后发生就从新表中取内容。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210512184328547.png" srcset="/img/loading.gif" lazyload alt="image-20210512184328547"></p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>1.7：Segment （ReentranLock）+ HashEntry + Unsafe</p>
<p>1.8：移除Segment分段锁，Synchronized + CAS使锁的粒度更小，使用相同的Node数组，提高了并发度。</p>
<p><strong>put</strong></p>
<p>1.7：先定位Segment，再定位桶，put全程加锁，没有获取锁的线程提前找桶的位置，并最多自旋64次获取锁，超过则挂起。</p>
<p>1.8：由于移除了Segment，类似HashMap，可以直接定位到桶，拿到first节点后进行判断，1、为空则CAS插入；2、为-1则说明在扩容，则跟着一起扩容；3、else则加锁put（类似1.7）</p>
<p><strong>resize</strong></p>
<p>1.7：跟HashMap步骤一样，只不过是搬到单线程中执行，避免了HashMap在1.7中扩容时死循环的问题，保证线程安全。</p>
<p>1.8：支持并发扩容，HashMap扩容在1.8中由头插改为尾插（为了避免死循环问题），ConcurrentHashmap也是，迁移也是从尾部开始，扩容前在桶的头部放置一个hash值为-1的节点，这样别的线程访问时就能判断是否该桶已经被其他线程处理过了。</p>
<p><strong>size</strong></p>
<p>1.7：尝试 2 次通过不锁住 Segment 的方式来统计各个 Segment 大小，如果统计的过程中，容器的 count 发生了变化，则再采用加锁的方式来统计所有Segment 的大小。</p>
<p>1.8：先尝试通过CAS 更新 baseCount 计数。某些线程 CAS 失败，有竞争发生就新建counterCells，向其中一个cell累加计数。最后就是baseCount加遍历cells数组的值。</p>
<p><strong>如何增加插入的效率：</strong></p>
<p>均匀散列，避免加锁。</p>
<p>通过配置负载因子和扩容大小来合理减少扩容的发生，提前使用spread（hash）计算对数据进行预处理，存在hash冲突的数据放在一个组里，这个组使用单线程的put操作，避免锁升级。</p>
<p><strong>为什么1.8使用 synchronized替换 可重入锁 ReentrantLock？</strong></p>
<ul>
<li><p>对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</p>
</li>
<li><p>减少内存开销，假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。</p>
</li>
</ul>
<p><strong>ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</strong></p>
<p>因为 ConcurrentHashMap 是用于多线程的 ，如果ConcurrentHashMap.get(key)得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。</p>
<p>如果是单线程的话，可以用contains函数来判断。但是多线程不可以，因为值是有可能会改变的。</p>
<h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1.对象头"></a>1.对象头</h3><p>普通对象头</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430145910433.png" srcset="/img/loading.gif" lazyload alt="image-20210430145910433"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430150118962.png" srcset="/img/loading.gif" lazyload alt="image-20210430150118962"></p>
<h3 id="2-Monitor"><a href="#2-Monitor" class="headerlink" title="2.Monitor"></a>2.Monitor</h3><p>多个线程遇到锁的时候：</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430150931126.png" srcset="/img/loading.gif" lazyload alt="image-20210430150931126"></p>
<h3 id="3-轻量级锁的流程"><a href="#3-轻量级锁的流程" class="headerlink" title="3.轻量级锁的流程"></a>3.轻量级锁的流程</h3><p>1.创建锁记录（Lock Record），每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定的对象MarkWord。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430191450591.png" srcset="/img/loading.gif" lazyload alt="image-20210430191450591"></p>
<p>2.让锁记录中的Object reference指向锁对象地址，并且尝试用CAS(compare and sweep)将栈帧中的锁记录的(lock record 地址 00)替换Object对象的Mark Word，将Mark Word 的值(01)存入锁记录(lock record地址)中 ——相互替换</p>
<p>其中，01是无锁状态，00是轻量级锁。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430191801401.png" srcset="/img/loading.gif" lazyload alt="image-20210430191801401"></p>
<p>3.如果CAS成功的话，对象头中存储了锁记录地址和状态00，表示由该线程给对象加锁。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430191954751.png" srcset="/img/loading.gif" lazyload alt="image-20210430191954751"></p>
<p>3.2如果失败了，有两种情况：</p>
<ul>
<li>如果是其他线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀。</li>
<li>如果是自己执行了synchronized锁重入，再添加一条LockRecord作为重入的计数。</li>
</ul>
<p>锁记录的过程可以看出到底加了几层锁。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430192837445.png" srcset="/img/loading.gif" lazyload alt="image-20210430192837445"></p>
<p>4.当退出的时候，如果存在null的锁记录，表示有重入，这个时候重入计数减一。</p>
<p>5.再次退出synchronized的时候，锁记录的值不为null，此时使用cas将MarkWord的值恢复给对象头</p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，则轻量级锁进行了膨胀或已经升级成了重量级锁，进入重量级锁解锁流程</li>
</ul>
<h3 id="4-锁膨胀"><a href="#4-锁膨胀" class="headerlink" title="4.锁膨胀"></a>4.锁膨胀</h3><p>1.当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁, 此时发生 <strong>锁膨胀</strong> </p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430194227678.png" srcset="/img/loading.gif" lazyload alt="image-20210430194227678"></p>
<p>2.因为Thread-1线程加轻量级锁失败, 轻量级锁没有阻塞队列的概念, 所以此时就要为对象申请Monitor锁(重量级锁)，让Object指向重量级锁地址 10，然后自己进入Monitor 的EntryList 变成BLOCKED状态。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430194631441.png" srcset="/img/loading.gif" lazyload alt="image-20210430194631441"></p>
<p>3.当Thread-0 线程执行完synchronized同步块时，使用cas将Mark Word的值恢复给对象头, 肯定恢复失败,因为对象的对象头中存储的是重量级锁的地址,状态变为10了之前的是00, 肯定恢复失败。那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的Thread-1线程。</p>
<h3 id="5-自旋优化"><a href="#5-自旋优化" class="headerlink" title="5.自旋优化"></a>5.自旋优化</h3><p>当发生<code>重量级锁竞争的时候</code>，还可以使用<code>自旋来进行优化 (不加入Monitor的阻塞队列EntryList中)</code>，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），<strong>那么当前线程就可以不用进行上下文切换</strong></p>
<ul>
<li>优化的点: 不用将<code>线程</code>加入到阻塞队列, 减少cpu切换.</li>
</ul>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430204409813.png" srcset="/img/loading.gif" lazyload alt="image-20210430204409813"></p>
<p>如果自旋失败的话就阻塞。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h3 id="6-偏向锁"><a href="#6-偏向锁" class="headerlink" title="6.偏向锁"></a>6.偏向锁</h3><p>那么java6开始引入了<code>偏向锁</code>，<strong>将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</strong></p>
<p>本来是需要锁重入的，现在只要检查ThreadID是否是自己的就可以了。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430212329941.png" srcset="/img/loading.gif" lazyload alt="image-20210430212329941"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210430214608362.png" srcset="/img/loading.gif" lazyload alt="image-20210430214608362"></p>
<ul>
<li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li>
<li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li>
<li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li>
</ul>
<p><strong>偏向锁撤销</strong></p>
<p>使用hashcode的时候。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/202012192322377.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>2.另外一个线程来使用，会把锁升级成轻量级锁。等到解锁以后，偏向状态就会被撤销。</p>
<p>3.当调用 wait/notify 时会被撤销，只有重量级锁才支持这两个方法，所以一定会先升级成重量级锁。</p>
<p><strong>批量重偏向</strong></p>
<ul>
<li>当<code>撤销偏向锁101 升级为 轻量级锁00</code>超过<code>20次后（超过阈值）</code>，JVM会觉得是不是偏向错了，这时会在<code>给对象加锁时，重新偏向至加锁线程 (T2)。</code></li>
</ul>
<p><strong>批量撤销偏向锁</strong></p>
<ul>
<li>当 撤销偏向锁的阈值超过40以后 ，就会将整个类的对象都改为<strong>不可偏向</strong>的</li>
</ul>
<h3 id="7-同步省略-锁消除"><a href="#7-同步省略-锁消除" class="headerlink" title="7.同步省略 (锁消除)"></a>7.同步省略 (锁消除)</h3><ul>
<li>在动态编译同步块的时候，<code>JIT(即时编译器)编译器</code>可以<code>借助逃逸分析</code>来判断同步块所<strong>使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</strong></li>
</ul>
<h3 id="8-锁升级的过程"><a href="#8-锁升级的过程" class="headerlink" title="8.锁升级的过程"></a>8.锁升级的过程</h3><p>首先是无锁状态，任何线程都可以通过CAS的方式来更改资源。</p>
<p>当一个线程多次重复使用锁的时候，升级为偏向锁，把对象头的一个标记设为01，记录线程ID，每次这个线程只要看到偏向为他，就不用使用CAS修改，直接修改就可以了。</p>
<p>另外一个线程二对对象加锁的时候，发现锁已经是偏向状态了，就升级锁为轻量级锁，在线程中创建一个锁记录，锁记录包含锁状态地址和对象指针。和对象中的Markword部分进行CAS交换，成功了的话，对象头就指向了这个锁记录，意思是对象被这个锁持有。</p>
<p>另外一个线程三对对象加锁的时候，发现是轻量级锁状态了，由于轻量级锁是没有队列的，就睡进行锁膨胀，创建一个Moniter监视器，此线程进入等待队列，Moniter当前owner线程指向线程二。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="1-锁优化的方式"><a href="#1-锁优化的方式" class="headerlink" title="1.锁优化的方式"></a>1.锁优化的方式</h3><ul>
<li>减小锁的粒度</li>
</ul>
<p>细粒度的锁，准备多个对象锁。是可以<code>增强并发度</code>。如果一个线程需要同时获得多把锁，就<code>容易发生死锁</code></p>
<ul>
<li>减少锁的持有时间</li>
</ul>
<p>只在需要的时候进行同步</p>
<ul>
<li>读写锁替换独占锁</li>
</ul>
<ul>
<li>锁分裂</li>
</ul>
<p>LinkedBlockingQueue是一个典型的例子</p>
<ul>
<li>锁粗化</li>
</ul>
<p>遇到连续的堆一个锁进行请求和释放的时候，便会把锁整合成一个。</p>
<h3 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2.ThreadLocal"></a>2.ThreadLocal</h3><p><strong>线程的局部变量</strong>，也就是说一个ThreadLocal的变量只有当前自身线程可以访问，别的线程都访问不了，那么自然就避免了线程竞争。为变量安全提供的解决思路。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ThreadLocal&lt;Integer&gt; localInt = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<span class="hljs-comment">//创建</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">setAndGet</span><span class="hljs-params">()</span></span>&#123;<br>    localInt.set(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> localInt.get();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol>
<li>传递数据：通过在同一线程中，不同组件传递公共变量。</li>
<li>线程隔离：每个线程的变量都是独立的，都会复制一份到自己这里</li>
</ol>
<p><strong>原理</strong></p>
<p>主要是使用ThreadLocalMap来实现的。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506094714734.png" srcset="/img/loading.gif" lazyload alt="image-20210506094714734"></p>
<p>当线程退出时，Thread会自动进行一些清理的工作：</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506095218262.png" srcset="/img/loading.gif" lazyload alt="image-20210506095218262"></p>
<p><strong>ThreadLocalMap的实现</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210522094125202.png" srcset="/img/loading.gif" lazyload alt="image-20210522094125202"></p>
<p>底层是一个数组结构，当有hash冲突产生的时候，就会寻找下一个空的地址写入。</p>
<p>get的时候会通过hash寻找ThreadLocal获取到的table的i值，查找数据对比是否和key值相等。</p>
<p><strong>内存泄露的问题：</strong></p>
<p>ThreadLocalMap中的key是弱引用，当不存在外部强引用的时候，就会自动被回收，但是Entry中的value依然是强引用</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506100017895.png" srcset="/img/loading.gif" lazyload alt="image-20210506100017895"></p>
<p>只有当Thread被回收时，这个value才有被回收的机会，否则，只要线程不退出，value总是会存在一个强引用。对于线程池来说，大部分线程会一直存在在系统的整个生命周期内，那样的话，就会造成value对象出现泄漏的可能。</p>
<p>此外，在使用set(),get()时还会在每个操作上检查key是否被回收，进而再回收value。</p>
<p>最好的方式：<strong>当你不需要这个ThreadLocal变量时，主动调用remove()，这样对整个系统是有好处的</strong>。</p>
<p><strong>ThreadLocal在性能上的提升</strong></p>
<p>如果共享对象容易引起性能损失，我们可以考虑使用ThreadLocal为每个对象单独分配单独的对象。</p>
<p>使用<strong>InheritableThreadLocal</strong>可以实现多个线程访问ThreadLocal的值</p>
<p><strong>ThreadLocal和synchronized关键字</strong></p>
<p>synchronized：同步机制采用’以时间换空间’的方式, 只提供了一份变量,让不同的线程排队访问。多个线程之间访问资源的同步。</p>
<p>ThreadLocal：以空间换时间’的方式, 为每一个线程都提供了一份变量的副本,从而实现同时访问而相不干扰。多线程中让每个线程之间的数据相互隔离</p>
<p><strong>ThreadLocal的应用：</strong></p>
<p>ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，如何防止自己的变量被其它线程篡改。</p>
<ol>
<li>Spring采用Threadlocal的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理connection对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。</li>
<li>多用户的日期读取，每个用户读取一个日历，可以用Threadlocal来隔离。用ThreadLocal包装一个日期类。</li>
<li>线程类的共享变量：request请求进入tomcat容器，进入Controller，进入service，再进入dao，如何共享这里的变量。user_id作为可共享的变量。service可以判断权限，dao使用id修改数据，log需要id来打印日志。</li>
</ol>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生的条件？</strong></p>
<ul>
<li>互斥条件<br>在一段时间内，一种资源只能被一个进程所使用</li>
<li>请求和保持条件<br>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li>
<li>不可抢占条件<br>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li>
<li>循环等待条件<br>发生死锁时，必然存在一个进程——资源的循环链。</li>
</ul>
<p><strong>如何避免死锁？</strong></p>
<p>避免同一个线程对多个锁进行锁定。</p>
<p>具有相同的加锁顺序。</p>
<p>使用定时锁，定时释放锁。</p>
<p><strong>实战：如何定位死锁</strong></p>
<p>命令jps查看进程</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501154930811.png" srcset="/img/loading.gif" lazyload alt="image-20210501154930811"></p>
<p>jstack 56004查看线程</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501155158851.png" srcset="/img/loading.gif" lazyload alt="image-20210501155158851"></p>
<p>第二种方法：</p>
<p>jconsole工具，直接检测死锁。</p>
<h2 id="无锁CAS"><a href="#无锁CAS" class="headerlink" title="无锁CAS"></a>无锁CAS</h2><h3 id="1-无锁的原理"><a href="#1-无锁的原理" class="headerlink" title="1.无锁的原理"></a>1.无锁的原理</h3><p>使用原子操作来保证线程访问共享资源的安全性, cas+重试的机制来确保(乐观锁思想), 相对于悲观锁思想的synchronized,reentrantLock来说, cas的方式效率会更好!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(prev,next))&#123;<br>            <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>pre是之前的值，next是要更新的值。pre获取余额的最新值，next要修改的余额。当共享变量和pre读到的是一致的时候，把next修改量赋值。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506192852886.png" srcset="/img/loading.gif" lazyload alt="image-20210506192852886"></p>
<ul>
<li>在上面代码中的AtomicInteger类，保存值的value属性使用了<strong>volatile 修饰</strong>。获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</li>
<li>volatile可以用来修饰 <strong>成员变量和静态成员变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</li>
</ul>
<h3 id="2-无锁效率以及特点"><a href="#2-无锁效率以及特点" class="headerlink" title="2.无锁效率以及特点"></a>2.无锁效率以及特点</h3><p>在无锁情况下，线程始终在高速运行，没有停歇。synchronized 会发生上下文切换，进入阻塞状态。</p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h3 id="3-工具类"><a href="#3-工具类" class="headerlink" title="3.工具类"></a>3.工具类</h3><h4 id="1）线程安全整数AtomicInteger"><a href="#1）线程安全整数AtomicInteger" class="headerlink" title="1）线程安全整数AtomicInteger"></a>1）线程安全整数AtomicInteger</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>    System.out.println(i.getAndIncrement());<br>    <br>    <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>    System.out.println(i.incrementAndGet());<br>    <br>    <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>    System.out.println(i.decrementAndGet());<br>    <br>    <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>    System.out.println(i.getAndDecrement());<br>    <br>    <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>    System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br>    <br>    <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>    System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br>    <br>    <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    <span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br>    <span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>    System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>    <br>    <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>&#125;<br></code></pre></td></tr></table></figure>



<p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>	AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);<br>	<br>    updateAndGet(i, <span class="hljs-keyword">new</span> IntUnaryOperator() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">applyAsInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operand)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> operand / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;);<br>    System.out.println(i.get()); <span class="hljs-comment">// 2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAndGet</span><span class="hljs-params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> prev = i.get(); <span class="hljs-comment">// 5</span><br>        <span class="hljs-keyword">int</span> next = operator.applyAsInt(prev);<br>        <span class="hljs-keyword">if</span> (i.compareAndSet(prev, next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-原子引用AtomicReference"><a href="#2-原子引用AtomicReference" class="headerlink" title="2) 原子引用AtomicReference"></a>2) 原子引用AtomicReference</h4><p>保证修改对象时得线程安全。</p>
<h4 id="3）AtomicStampedReference"><a href="#3）AtomicStampedReference" class="headerlink" title="3）AtomicStampedReference"></a>3）AtomicStampedReference</h4><p>携带版本号可以解决ABA的问题，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>

<ul>
<li><strong><code>AtomicStampedReference</code></strong> 需要我们传入 <strong><code>整型变量</code></strong> 作为<code>版本号</code>，来判定是否被更改过</li>
<li>**<code>AtomicMarkableReference</code>*<em>需要我们传入*</em><code>布尔变量</code>** 作为<code>标记</code>，来判断是否被更改过</li>
</ul>
<h4 id="4）AtomicIntegerArray线程安全的数组"><a href="#4）AtomicIntegerArray线程安全的数组" class="headerlink" title="4）AtomicIntegerArray线程安全的数组"></a>4）AtomicIntegerArray线程安全的数组</h4><h4 id="5）AtomicReferenceFieldUpdater"><a href="#5）AtomicReferenceFieldUpdater" class="headerlink" title="5）AtomicReferenceFieldUpdater"></a>5）AtomicReferenceFieldUpdater</h4><p>保证<code>多线程</code>访问<code>同一个对象的成员变量</code>时, <code>成员变量的线程安全性</code>。作用在普通对象或者变量上。</p>
<ul>
<li><code>AtomicReferenceFieldUpdater</code> —引用类型的属性</li>
<li>AtomicIntegerFieldUpdater —整形的属性</li>
<li>AtomicLongFieldUpdater —长整形的属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> AtomicReferenceFieldUpdater()<br></code></pre></td></tr></table></figure>

<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506212354707.png" srcset="/img/loading.gif" lazyload alt="image-20210506212354707"></p>
<h4 id="6）LongAdder更快的累加器"><a href="#6）LongAdder更快的累加器" class="headerlink" title="6）LongAdder更快的累加器"></a>6）LongAdder更快的累加器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> LongAdder(), adder -&gt; adder.increment());<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>LongAdder性能&gt;原子类&gt;大于锁</p>
<p><strong>伪共享问题：</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506220032817.png" srcset="/img/loading.gif" lazyload alt="image-20210506220032817"></p>
<ul>
<li>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：<ul>
<li>Core-0 要修改 Cell[0]</li>
<li>Core-1 要修改 Cell[1]</li>
</ul>
</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效。</li>
</ul>
<p><strong>add方法的实现：</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506220659410.png" srcset="/img/loading.gif" lazyload alt="image-20210506220659410"></p>
<h4 id="7）Usafe"><a href="#7）Usafe" class="headerlink" title="7）Usafe"></a>7）Usafe</h4><ul>
<li>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<code>反射</code>获得</li>
<li>可以发现<code>AtomicInteger</code>以及其他的原子类, 底层都使用的是<code>Unsafe</code>类</li>
</ul>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508152121917.png" srcset="/img/loading.gif" lazyload alt="image-20210508152121917"></p>
<p>如果不是系统调用，那就抛出异常。</p>
<h2 id="多线程的设计模式"><a href="#多线程的设计模式" class="headerlink" title="多线程的设计模式"></a>多线程的设计模式</h2><h3 id="1-同步模式保护性暂停"><a href="#1-同步模式保护性暂停" class="headerlink" title="1.同步模式保护性暂停"></a>1.同步模式保护性暂停</h3><p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/8af156fb943083720b551f6e52ddd03c.png" srcset="/img/loading.gif" lazyload alt="1594518049426"></p>
<ul>
<li><strong>这个<code>产生结果的线程</code>和<code>使用结果的线程</code>是<code>一一对应</code>的关系，但是生产者消费者模式并不是。</strong></li>
<li>rpc框架的调用中就使用到了这种模式。</li>
</ul>
<h3 id="2-单例模式（重要）"><a href="#2-单例模式（重要）" class="headerlink" title="2.单例模式（重要）"></a>2.单例模式（重要）</h3><p>饿汉式：类加载就会导致该单实例对象被创建。</p>
<p>懒汉式：类加载不会创建，首次使用的时候会创建。</p>
<p><strong>饿汉式实现：</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501204227873.png" srcset="/img/loading.gif" lazyload alt="image-20210501204227873"></p>
<p>问题1 : 加final为了防止有子类, 因为子类可以重写父类的方法<br>问题2 : 首先通过反序列化操作, 也是可以创建一个对象的, 破坏了单例, 可以使用readResolve方法并返回instance对象, 当反序列化的时候就会调用自己写的readResolve方法<br>问题3 : 私有化构造器, 防止外部通过构造器来创建对象; 但不能防止反射来创建对象<br>问题4 : 因为单例对象是static的, 静态成员变量的初始化操作是在类加载阶段完成, 由JVM保证其线程安全 (这其实是利用了ClassLoader的线程安全机制。ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。)<br>问题5 : 通过向外提供公共方法, 体现了更好的封装性, 可以在方法内实现懒加载的单例; 可以提供泛型等<br>补充 : 任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。</p>
<p><strong>枚举实现单例：</strong>（饿汉式）</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210501210636742.png" srcset="/img/loading.gif" lazyload alt="image-20210501210636742"></p>
<p>问题1 : 枚举类中, 只有一个INSTANCE, 就确保了它是单例的<br>问题2 : 没有并发问题, 是线程安全的, 因为枚举单例底层是一个静态成员变量, 它是通过类加载器的加载而创建的, 确保了线程安全<br>问题3 : 反射无法破坏枚举单例, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。<br>if ((this.clazz.getModifiers() &amp; 16384) != 0)<br>throw new IllegalArgumentException(“Cannot reflectively create enum objects”);<br>问题4 : 反序列化不能破坏, 枚举类默认也实习了序列号接口. 但枚举类考虑到了这个问题, 不会破坏单例. 通过反序列化得到的并不是同一个单例对象; 除此之外, 还可以写上readResolve方法,<br>问题 5 : 属于饿汉式, 静态成员变量, 通过类加载器的时候就加载了。<br>问题 6 : 加构造方法</p>
<p><strong>懒汉式实现：</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506102412666.png" srcset="/img/loading.gif" lazyload alt="image-20210506102412666"></p>
<p>懒汉式实现（DCL实现）：</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210506102444374.png" srcset="/img/loading.gif" lazyload alt="image-20210506102444374"></p>
<p>懒汉式实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-comment">// 问题2：在创建时是否有并发问题，这是线程安全的，类加载时，jvm保证类加载操作的线程安全</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-不变模式"><a href="#3-不变模式" class="headerlink" title="3.不变模式"></a>3.不变模式</h3><p>对象创建后，内部状态不再变化。对象会被共享，频繁的访问。</p>
<p>创建不变模式的要素：</p>
<ul>
<li>没有修改属性的方法</li>
<li>属性是私有且final的</li>
<li>有一个完整创建对象的构造函数</li>
</ul>
<p>例子：JDK8中有一个DateTimeFormatter，不可变日期格式化类。</p>
<p><strong>final字段的使用</strong></p>
<ul>
<li>Integer、Double、String、DateTimeFormatter以及基本类型包装类, 都是使用<code>final</code>来修饰的</li>
</ul>
<p>保护性拷贝，string在构造新的字符串时，会生成新的char[] value，并且对内容进行复制。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508154207880.png" srcset="/img/loading.gif" lazyload alt="image-20210508154207880"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210508154235928.png" srcset="/img/loading.gif" lazyload alt="image-20210508154235928"></p>
<p><strong>final的原理</strong></p>
<p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况。</p>
<p>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。编译器会在final域的写之后，插入一个StoreStore屏障。</p>
<p>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。编译器会在读final域操作的前面插入一个LoadLoad屏障 。</p>
<p>设置final时，会添加一个写屏障，保证变量写入内存，对其他变量的可见性。</p>
<h3 id="4-享元模式"><a href="#4-享元模式" class="headerlink" title="4.享元模式"></a>4.享元模式</h3><p><strong>例子：</strong>在JDK中<code>Boolean，Byte，Short，Integer，Long，Character</code>等包装类提供了<code>valueOf</code>方法，例如 Long 的<code>valueOf</code>会缓存<code>-128~127</code>之间的 Long 对象，<strong>在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-keyword">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Long(l);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h2><h3 id="1-实现阻塞队列"><a href="#1-实现阻塞队列" class="headerlink" title="1.实现阻塞队列"></a>1.实现阻塞队列</h3><p>BlockingQueue<T> 参数设置：</p>
<p>任务队列，锁，生产者条件变量，消费者条件变量，阻塞队列容量。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210517141534591.png" srcset="/img/loading.gif" lazyload alt="image-20210517141534591"></p>
<p>实现take方法，获取任务，无任务则一直等待</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210517141900116.png" srcset="/img/loading.gif" lazyload alt="image-20210517141900116"></p>
<p>实现put方法，阻塞队列添加任务。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210517145402750.png" srcset="/img/loading.gif" lazyload alt="image-20210517145402750"></p>
<p>poll方法会超时返回</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210517143542721.png" srcset="/img/loading.gif" lazyload alt="image-20210517143542721"></p>
<p>offer方法，往阻塞队列添加任务，超时返回。</p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210517145452612.png" srcset="/img/loading.gif" lazyload alt="image-20210517145452612"></p>
<h3 id="2-实现线程池"><a href="#2-实现线程池" class="headerlink" title="2.实现线程池"></a>2.实现线程池</h3><p>线程池参数：</p>
<p>任务队列blockingQueue，线程集合HashMap，核心线程数，最大线程数，</p>
<p><strong>执行任务：</strong></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210517150453337.png" srcset="/img/loading.gif" lazyload alt="image-20210517150453337"></p>
<p><img src="/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20210517151235229.png" srcset="/img/loading.gif" lazyload alt="image-20210517151235229"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
